omid_server

Endpoint OmidServer;

Struct player_data {
    Endpoint player_helper;
    Number score;
}

Struct node_information {
    Text answer;
    Text node_num;
    Number x;
    Number y;
    TrueFalse found;
}


Struct arc_information {
    Text node1;
    Text node2;
}

OmidServer {
    Map(from: Text, to: Struct node_information) nodes;
    Map(from: Text, to: Endpoint) waiting_room;
    Map(from: Text, to: Struct player_data) game;
    List(element: Struct arc_information) arcs;
    TrueFalse game_in_session = False;
    
    Public Function set_map(Map(from: Text, to: Struct node_information) node_map, List(element: Struct arc_information) arc_list) {
        nodes = node_map;
        arcs = arc_list;
    }

    Public Function add_to_waiting(Text username, Endpoint endpt) {
        waiting_room[username] = endpt;
    }

    Public Function start_game() {
        game_in_session = True;
        for (Text player in game) {
            game[player].player_helper.init_map(nodes, arcs);
        }
    }

    Public Function update_maps(Text answer) {
        for (Text user in game) {
            game[user].player_helper.update_map(answer);
        }
    }

    Public Function check_node(Text username, Text node_number, Text answer) returns Number{
        if (answer in nodes) {
            if (node_number == nodes[answer].node_num) {
                if (not nodes[answer].found) {
                    nodes[answer].found = True;
                    game[username].score += 5;
                    update_maps(answer);
                }
                //Tell user node has already been found
            }
        }
        //Tell incorrect
        return game[username].score;
    }

    Public Function get_player_count() returns Number{
        return len(game);
    }

    Public Function add_user(Text username, Endpoint node) {
        Text message = username + " has entered the waiting room.\n";
        broadcastWaitingMessage(message);
        waiting_room[username] = node;
    }

    Public Function remove_from_waiting(Text username) {
        Text message = username + " has left the waiting room.\n";
        waiting_room.remove(username);
        broadcastWaitingMessage(message);
    }
    
    Public Function get_score(Text username) returns Number {
        return game[username].score;
    }
    
    Public Function add_player(Text username) {
        Text message = username + " is in the game room.\n";
        Struct player_data player;
        player.score = 0;
        player.player_helper = waiting_room[username];
        game[username] = player;
        broadcastWaitingMessage(message);
    }
    /*  Public Function broadcastMessage(Text message) {
        for (Text username in game) {
            game[username].player_helper.get_new_game_message(message);
        }
    }
*/    
    Public Function broadcastWaitingMessage(Text message) {
        for (Text username in waiting_room) {
            waiting_room[username].get_new_waiting_message(message);
        }
    }
    Public Function check_game_in_session() returns TrueFalse {
        return game_in_session;
    }

    Public Function end_game() {
        game_in_session = False;
        /*  game_over = True;
        Text message = 'Game Over\n';
        for (Text username in game) {
            message += username + ' - ' + toText(game[username].score) + '\n';
        }
        broadcastMessage(message);*/
        game = {};
    }
}
