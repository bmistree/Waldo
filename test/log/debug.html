<!DOCTYPE html>
<html>
	<head>
		<script type="text/javascript" src="d3.min.js"></script>
		<script type="text/javascript" src="jquery-2.0.3.min.js"></script>

		<script type="text/javascript">
		var fileContent='';
		var theLocation='./master.txt';

		</script>
	</head>
	<body>
		<p>Hello!</p>
		<style>
		  #byte_content {
		    margin: 5px 0;
		    max-height: 100px;
		    overflow-y: auto;
		    overflow-x: hidden;
		  }
		  #byte_range { margin-top: 5px; }
		</style>

		<form id="search" action="javascript:loadData(true, null)">
		        <input type="text" class="input" id="bar" size="21" maxlength="120"><input type="submit" value="search">
		</form>

		<input type="file" id="files" name="file" /> Read bytes: 
		<span class="readBytesButtons">
		  <button>Visualize</button>
		</span>
		<p>Endpoint IDs</p>
		<span class="endPointIDs">
		</span>
		<span class="varIDs">
		</span>
		<div class="infobox">
			<p class="change">Here is where we will say something.</p>
		</div>
		<div id="byte_range"></div>
		<div id="byte_content"></div>


		<script>
			var dataset;
			function extend(arr) {
				for (var i = 0; i < arr.length; i++) {
				}
				return arr;
			}
			function serialize(arr) {
				for (var i = 0; i < arr.length; i++) {
					arr[i].time = new Date(arr[i].time);				
				}
				return arr;
			}

			function loadData(bool, content) {
				if (!bool) {
					dataset = jQuery.parseJSON(content);
				}

				var eventIDs = [];
				var endpointIDs = [];
				var varIDs = []
				$.each(dataset, function(i, el){
    				if($.inArray(el.eventID, eventIDs) === -1) eventIDs.push(el.eventID);
    				if($.inArray(el.endpointID, endpointIDs) === -1) endpointIDs.push(el.endpointID);
    				if($.inArray(el.container, varIDs) === -1 && el.container != undefined) varIDs.push(el.container);

				});
				d3.selectAll(".endpointIDs")
					.data([]).exit().remove();
				d3.select("body").selectAll(".endpointIDs")
					.data(endpointIDs).enter()
					.append("input").attr("type","button").attr("class","endpointIDs").attr("value", function (d) {return d;} )
					.on("click", function(d) {
						document.getElementById("bar").value = d;
						loadData(true, null);
					});

				d3.selectAll(".varIDs")
					.data([]).exit().remove();
				d3.select("body").selectAll(".varIDs")
					.data(varIDs).enter()
					.append("input").attr("type","button").attr("class","varIDs").attr("value", function (d) {return d;} )
					.on("click", function(d) {
						document.getElementById("bar").value = d;
						console.log(d);
						loadData(true, null);
					});

				var holder = {};

				for (var i = 0; i < eventIDs.length; i++) {
					holder[eventIDs[i]] = new Array();
				}
				for (var x = 0; x < dataset.length; x++) {
					var e = dataset[x];
					var eID = e.eventID;
				    holder[eID].push(e);
				}
				
				d3.select("svg").remove()
				var w = 5000;
				var h = 5000;
				var svg = d3.select("body")
				            .append("svg")
				            .attr("width", w)   // <-- Here
				            .attr("height", h);	
				var colors = {};
				colors["Endpoint"] = "green";
				colors["Finished"] = "black";
				colors["Read"] = "yellow";
				colors["Write"] = "blue";
				colors["UpdateContainer"] = "red";
				colors["DeleteContainerValue"] = "purple";
				
				var list = {};
				var circles = svg.selectAll("circle")
    				.data(eventIDs)
    				.enter()
    				.append("circle")
    				.attr("cx", function(d, i) {
            		return 50; 
        			})
       				.attr("cy", function(d, i) {
       					list[d] = i;
            			return (i * 50) + 25;
        			})
       				.attr("r", function(d, i) {
            			return 20;
       				});

       			svg.selectAll("text")
       			.data(eventIDs)
       			.enter()
       			.append("text")
       			.attr("x", function(d, i) {
            		return 75;
        		})
        		.attr("y", function(d, i) {
            		return (i * 50) + 25;
        		})
        		.attr("font-size", "15px")
        		.text(function(d){return d});
        		
        		var keys = Object.keys(holder);
        		var tracker = {};
        		for (var key = 0; key < keys.length; key++) {
        			tracker[keys[key]] = 0;
        		}
        		var superArray = [];
        		for (var data = 0; data < keys.length; data++) {
        			superArray = superArray.concat(holder[keys[data]]);
        		}
        			var xAxis = 0;
	    			var rects = svg.selectAll("rect")
	    				.data(superArray)
	    				.enter()
	    				.append("rect")
						.attr("class", keys[data])
	    				.attr("x", function(d, i) {
	    					tracker[d.eventID]++;
	            			return 50 + (tracker[d.eventID] * 50); 
	        			})
	       				.attr("y", function(d, i) {
	            			return 25+(50*list[d.eventID]);
	        			})
	       				.attr("width", 40)
	       				.attr("height", 20)
	       				.attr("rx", 2)
	       				.attr("ry", 2)
	       				.attr("fill", function(d) {
	       					return colors[d.type];
	       				})
	       				.attr("opacity", function(d) {
	       					if (bool) {
	       						var name = document.getElementById("bar").value;
	       						console.log(d);
	       						if (d.endpointID.indexOf(name) != -1) {
	       							return 1;
	       						}
	       						else if (d.container != undefined) {
	       							if (d.container.indexOf(name) != -1) {
	       								return 1;
	       							}
	       							else {
	       								return 0.25;
	       							}
	       						}
	       						else {
	       							return 0.25;
	       						}
	       					}
	       					else {
	       						return 1;
	       					}
	       				})
	       				.attr("stroke", "black")
	       				.on('mouseover', function(d) {
							var rect = d3.select(this);
							// show infobox div on mouseover.
							// block means sorta "render on the page" whereas none would mean "don't render at all"
							d3.select(".infobox").style("display", "block");	
							// add test to p tag in infobox
							if (d.type == "Endpoint" || d.type == "Finished") {
								d3.select(".change").text("EventID: " + d.eventID + "; endpointID: " + d.endpointID + "; type: " + d.type + "; time: " + d.time);
							}
							if (d.type == "Read") {
								d3.select(".change").text("EventID: " + d.eventID + "; endpointID: " + d.endpointID + "; type: " + d.type + ";container: " + d.container + 
									"; value: " + d.value + "; time: " + d.time);
							}
							if (d.type == "Write") {
								d3.select(".change").text("EventID: " + d.eventID + "; endpointID: " + d.endpointID + "; type: " + d.type + ";container: " + d.container + 
									"; oldValue" + d.oldValue + "; value: " + d.value + "; time: " + d.time);
							}
							if (d.type == "UpdateContainer") {
								d3.select(".change").text("EventID: " + d.eventID + "; endpointID: " + d.endpointID + "; type: " + d.type + ";container: " + d.container + 
									"; fieldUpdate: " + d.fieldUpdate + "; oldValue" + d.oldValue + "; value: " + d.value + "; time: " + d.time);
							}
						});
       		//	}



			}
			function readBlob(opt_startByte, opt_stopByte) {

			    var files = document.getElementById('files').files;
			    if (!files.length) {
			      alert('Please select a file!');
			      return;
			    }

			    var file = files[0];
			    var start = parseInt(opt_startByte) || 0;
			    var stop = parseInt(opt_stopByte) || file.size - 1;

			    var reader = new FileReader();

			    // If we use onloadend, we need to check the readyState.
			    reader.onloadend = function(evt) {
			      if (evt.target.readyState == FileReader.DONE) { // DONE == 2
			        var content = evt.target.result;
			        loadData(false, content);
			      }
			    };

			    var blob = file.slice(start, stop + 1);
			    reader.readAsText(blob);
		  	}
		  
		  document.querySelector('.readBytesButtons').addEventListener('click', function(evt) {
		    if (evt.target.tagName.toLowerCase() == 'button') {
		      var startByte = evt.target.getAttribute('data-startbyte');
		      var endByte = evt.target.getAttribute('data-endbyte');
		      readBlob(startByte, endByte);
		    }
		  }, false);
		</script>
    		
	</body>
</html>