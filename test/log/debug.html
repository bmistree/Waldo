<!DOCTYPE html>
<html>
	<head>
		<script type="text/javascript" src="d3.min.js"></script>
		<script type="text/javascript" src="jquery-2.0.3.min.js"></script>

		<script type="text/javascript">
		var fileContent='';
		var theLocation='./master.txt';

		</script>
	</head>
	<body>
		<p>Hello!</p>
		<style>
		  #byte_content {
		    margin: 5px 0;
		    max-height: 100px;
		    overflow-y: auto;
		    overflow-x: hidden;
		  }
		  #byte_range { margin-top: 5px; }
		</style>

		<input type="file" id="files" name="file" /> Read bytes: 
		<span class="readBytesButtons">
		  <button>Visualize</button>
		</span>
		<div class="infobox">
			<p class="change">Here is where we will say something.</p>
		</div>
		<div id="byte_range"></div>
		<div id="byte_content"></div>

		<script>
			function extend(arr) {
				for (var i = 0; i < arr.length; i++) {
					console.log(arr[i].time);
					console.log(Object.prototype.toString.call(arr[i].time));

				}
				return arr;
			}
			function serialize(arr) {
				for (var i = 0; i < arr.length; i++) {
					arr[i].time = new Date(arr[i].time);
					console.log(arr[i].time);
					console.log(arr[i].time.getUTCMilliseconds())
				}
				/*arr.sort(function(x, y){
					console.log(x.time);
					x.time = new Date(x.time);
					console.log(Object.prototype.toString.call(x.time));
					console.log("Time is " + (x.time - y.time));
    				return x.time - y.time;
				});
				for (var i = 0; i < arr.length; i++) {
					console.log("Changing " + arr[i].time  +"to " + (i+1))
					arr[i].time = i+1;
				}*/
				return arr;
			}
			var myMouseOverFunction = function() {
				var rect = d3.select(this);
 				console.log("LOOK");
				// show infobox div on mouseover.
				// block means sorta "render on the page" whereas none would mean "don't render at all"
				d3.select(".infobox").style("display", "block");	
				// add test to p tag in infobox
				d3.select(".change").text(rect.attr("rx"));
			}
			function loadData(content) {
				var dataset = jQuery.parseJSON(content);

				var eventIDs = [];
				$.each(dataset, function(i, el){
    				if($.inArray(el.eventID, eventIDs) === -1) eventIDs.push(el.eventID);
				});

				var holder = {};

				for (var i = 0; i < eventIDs.length; i++) {
					holder[eventIDs[i]] = new Array();
				}
				for (var x = 0; x < dataset.length; x++) {
					var e = dataset[x];
					var eID = e.eventID;
				    holder[eID].push(e);
				}
				

				var w = 5000;
				var h = 5000;
				var svg = d3.select("body")
				            .append("svg")
				            .attr("width", w)   // <-- Here
				            .attr("height", h);	
				var colors = {};
				colors["Endpoint"] = "green";
				colors["Finished"] = "black";
				colors["Read"] = "yellow";
				colors["Write"] = "blue";
				colors["UpdateContainer"] = "red";
				colors["DeleteContainerValue"] = "purple";

				
				var list = {};
				var circles = svg.selectAll("circle")
    				.data(eventIDs)
    				.enter()
    				.append("circle")
    				.attr("cx", function(d, i) {
            		return 50; 
        			})
       				.attr("cy", function(d, i) {
       					list[d] = i;
            			return (i * 50) + 25;
        			})
       				.attr("r", function(d, i) {
            			return 20;
       				});

       			svg.selectAll("text")
       			.data(eventIDs)
       			.enter()
       			.append("text")
       			.attr("x", function(d, i) {
            		return 75;
        		})
        		.attr("y", function(d, i) {
            		return (i * 50) + 25;
        		})
        		.attr("font-size", "15px")
        		.text(function(d){return d});
        		
        		var keys = Object.keys(holder);
        		var tracker = {};
        		for (var key = 0; key < keys.length; key++) {
        			tracker[keys[key]] = 0;
        		}
        		var superArray = [];
        		for (var data = 0; data < keys.length; data++) {
        			console.log(holder[keys[data]]);
        			superArray = superArray.concat(holder[keys[data]]);
        		}
        		console.log("super Array length:" + superArray.length)
        			var xAxis = 0;
	    			var rects = svg.selectAll("rect")
	    				.data(superArray)
	    				.enter()
	    				.append("rect")
						.attr("class", keys[data])
	    				.attr("x", function(d, i) {
	    					tracker[d.eventID]++;
	            			return 50 + (tracker[d.eventID] * 50); 
	        			})
	       				.attr("y", function(d, i) {
	       					console.log("Data is " + i);
	       					console.log(d);
	            			return 25+(50*list[d.eventID]);
	        			})
	       				.attr("width", 40)
	       				.attr("height", 20)
	       				.attr("rx", 2)
	       				.attr("ry", 2)
	       				.attr("fill", function(d) {
	       					return colors[d.type];
	       				})
	       				.attr("stroke", "black")
	       				.on('mouseover', function(d) {
							var rect = d3.select(this);
							// show infobox div on mouseover.
							// block means sorta "render on the page" whereas none would mean "don't render at all"
							d3.select(".infobox").style("display", "block");	
							// add test to p tag in infobox
							if (d.type == "Endpoint" || d.type == "Finished") {
								d3.select(".change").text("EventID: " + d.eventID + "; endpointID: " + d.endpointID + "; type: " + d.type + "; time: " + d.time);
							}
							if (d.type == "Read") {
								d3.select(".change").text("EventID: " + d.eventID + "; endpointID: " + d.endpointID + "; type: " + d.type + ";container: " + d.container + 
									"; value: " + d.value + "; time: " + d.time);
							}
							if (d.type == "Write") {
								d3.select(".change").text("EventID: " + d.eventID + "; endpointID: " + d.endpointID + "; type: " + d.type + ";container: " + d.container + 
									"; oldValue" + d.oldValue + "; value: " + d.value + "; time: " + d.time);
							}
							if (d.type == "UpdateContainer") {
								d3.select(".change").text("EventID: " + d.eventID + "; endpointID: " + d.endpointID + "; type: " + d.type + ";container: " + d.container + 
									"; fieldUpdate: " + d.fieldUpdate + "; oldValue" + d.oldValue + "; value: " + d.value + "; time: " + d.time);
							}
						});
       		//	}



			}
			function readBlob(opt_startByte, opt_stopByte) {

			    var files = document.getElementById('files').files;
			    if (!files.length) {
			      alert('Please select a file!');
			      return;
			    }

			    var file = files[0];
			    var start = parseInt(opt_startByte) || 0;
			    var stop = parseInt(opt_stopByte) || file.size - 1;

			    var reader = new FileReader();

			    // If we use onloadend, we need to check the readyState.
			    reader.onloadend = function(evt) {
			      if (evt.target.readyState == FileReader.DONE) { // DONE == 2
			        var content = evt.target.result;
			        loadData(content);
			      }
			    };

			    var blob = file.slice(start, stop + 1);
			    reader.readAsText(blob);
		  	}
		  
		  document.querySelector('.readBytesButtons').addEventListener('click', function(evt) {
		    if (evt.target.tagName.toLowerCase() == 'button') {
		      var startByte = evt.target.getAttribute('data-startbyte');
		      var endByte = evt.target.getAttribute('data-endbyte');
		      readBlob(startByte, endByte);
		    }
		  }, false);
		</script>
    		
	</body>
</html>